# --------------------------------------------------
# ~/.zsh_functions
# --------------------------------------------------

# ---- helpers ----
#
_slurm_blue() { printf "\033[34m"; }
_slurm_reset() { printf "\033[0m"; }

# ---- lsjobs  ----
#
# list all (user) jobs in a human-readable format
#
lsjobs() {
  local who="${1:-$USER}"
  local BLUE="\033[34m" RESET="\033[0m"

  squeue -u "$who" -h -o "%i|%t|%P|%j|%C|%m|%M|%D|%R" | awk -F'|' \
    -v BLUE="$BLUE" -v RESET="$RESET" '
    BEGIN {
      printf "%-10s %-5s %-14s %-26s %-4s %-6s %-10s %-5s %s\n",
             "JOBID","ST","PARTITION","NAME","CPU","MEM","TIME","NODES","WHERE/REASON"
    }
    {
      # colorize only the JOBID column
      printf "%s%-10s%s %-5s %-14s %-26.26s %-4s %-6s %-10s %-5s %s\n",
             BLUE, $1, RESET,
             $2, $3, $4, $5, $6, $7, $8, $9
    }'
}

# ---- lsnodes ----
#
# list all the nodes in a human-readable format
#
lsnodes() {
  local part="$1"
  local BLUE="\033[34m" RESET="\033[0m"

  local fmt="%15N %4c %7m %46f %18G"
  local cmd=(sinfo -h -o "$fmt")
  [[ -n "$part" ]] && cmd+=(-p "$part")

  printf "%-15s %-4s %-7s %-46s %-18s\n" "NODELIST" "CPUS" "MEM" "FEATURES" "RESOURCES"

  "${cmd[@]}" | awk -v BLUE="$BLUE" -v RESET="$RESET" '
    function trim(s){ sub(/^[[:space:]]+/, "", s); sub(/[[:space:]]+$/, "", s); return s }

    # sinfo %m is MB (usually). Keep non-numeric values like 56000+ as-is.
    function human_mem(m, gb){
      if (m !~ /^[0-9]+$/) return m
      gb = m/1024.0
      if (gb >= 1024.0) return sprintf("%.1fT", gb/1024.0)
      return sprintf("%.0fG", gb)
    }

    # Make resources readable but keep the raw label visible.
    # gpu:h100:3 -> 3_H100 (gpu:h100:3)
    function human_gres_with_raw(g,   out,n,i,raw,base,tok,parts){
      g = trim(g)
      if (g=="" || g=="(null)" || g=="N/A") return "-"

      n = split(g, parts, ",")
      out = ""
      for (i=1; i<=n; i++) {
        raw = trim(parts[i]); if (raw=="") continue
        base = raw; sub(/\(.*/, "", base)  # drop (S:0-1) from parsing only

        tok = raw
        if (match(base, /^gpu:([^:]+):([0-9]+)$/, m)) {
          tok = m[2] "_" toupper(m[1]) " (" raw ")"
        } else if (match(base, /^gpu:([^:]+)$/, m2)) {
          tok = toupper(m2[1]) " (" raw ")"
        }

        if (out!="") out = out ", "
        out = out tok
      }
      return out
    }

    {
      nl   = trim(substr($0, 1, 15))
      cpus = trim(substr($0, 17, 4))
      mem  = trim(substr($0, 22, 7))
      feat = trim(substr($0, 30, 46))
      gres = trim(substr($0, 77, 18))

      printf("%s%-15s%s %-4s %-7s %-46s %s\n",
             BLUE, nl, RESET,
             cpus,
             human_mem(mem),
             feat,
             human_gres_with_raw(gres))
    }'
}

# ---- lsparts ----
#
# list partitions (and projects)  in a human-readable format
#
lsparts() {
  local BLUE="\033[34m" RESET="\033[0m"

  sinfo -h -o "%P|%D|%C" | awk -F'|' -v BLUE="$BLUE" -v RESET="$RESET" '
    {
      pname=$1; nodes=$2; c=$3
      suffix=""
      if (pname ~ /\*$/) { sub(/\*$/, "", pname); suffix=" (default)" }

      split(c, a, "/") # alloc/idle/other/total

      printf("%s%-20s%s %4s nodes, %4s idle CPUs / %s%s\n",
             BLUE, pname, RESET,
             nodes, a[2], a[4], suffix)
    }'
}

# ---- sumjob ----
# 
# summarize the job with <jobid>
# sumjob <jobid>
#
sumjob() {
  local jobid="$1"
  if [[ -z "$jobid" ]]; then
    echo "Usage: sumjob <jobid>"
    echo "Tip:   lsjobs"
    return 1
  fi

  local BLUE="\033[34m" RESET="\033[0m"

  # scontrol is the most reliable for a single job snapshot.
  scontrol show job "$jobid" 2>/dev/null | awk \
    -v BLUE="$BLUE" -v RESET="$RESET" '
    {
      for (i=1; i<=NF; i++) {
        split($i, kv, "=")
        if (kv[1] != "" && kv[2] != "") v[kv[1]] = kv[2]
      }
    }
    END {
      if (!v["JobId"]) { print "Job not found: " ENVIRON["jobid"]; exit 0 }

      printf("%sJob:%s         %s\n", BLUE, RESET, v["JobId"])
      if (v["JobName"]) printf("%sName:%s        %s\n", BLUE, RESET, v["JobName"])
      if (v["UserId"])  printf("%sUser:%s        %s\n", BLUE, RESET, v["UserId"])
      if (v["Partition"]) printf("%sPartition:%s   %s\n", BLUE, RESET, v["Partition"])
      if (v["State"])   printf("%sState:%s       %s\n", BLUE, RESET, v["State"])
      if (v["Reason"])  printf("%sReason:%s      %s\n", BLUE, RESET, v["Reason"])

      if (v["SubmitTime"]) printf("%sSubmitted:%s   %s\n", BLUE, RESET, v["SubmitTime"])
      if (v["StartTime"])  printf("%sStart:%s       %s\n", BLUE, RESET, v["StartTime"])
      if (v["RunTime"])    printf("%sRunTime:%s     %s\n", BLUE, RESET, v["RunTime"])
      if (v["TimeLimit"])  printf("%sTimeLimit:%s   %s\n", BLUE, RESET, v["TimeLimit"])

      if (v["NumNodes"])   printf("%sNodes:%s       %s\n", BLUE, RESET, v["NumNodes"])
      if (v["NodeList"])   printf("%sNodeList:%s    %s\n", BLUE, RESET, v["NodeList"])

      if (v["NumCPUs"])    printf("%sCPUs:%s        %s\n", BLUE, RESET, v["NumCPUs"])
      if (v["ReqMem"])     printf("%sReqMem:%s      %s\n", BLUE, RESET, v["ReqMem"])
      if (v["TRES"])       printf("%sTRES:%s        %s\n", BLUE, RESET, v["TRES"])
      if (v["Gres"])       printf("%sGres:%s        %s\n", BLUE, RESET, v["Gres"])
      if (v["StdOut"])     printf("%sStdOut:%s      %s\n", BLUE, RESET, v["StdOut"])
      if (v["StdErr"])     printf("%sStdErr:%s      %s\n", BLUE, RESET, v["StdErr"])
    }' jobid="$jobid"
}

# ---- sumnode ----
#
# summarize the node <nodeid>
# sumnode <nodeid>
#
sumnode() {
  local node="$1"
  if [[ -z "$node" ]]; then
    echo "Usage: sumnode <node>"
    echo "Tip:   lsnodes"
    return 1
  fi

  local BLUE="\033[34m"
  local RESET="\033[0m"

  scontrol show node "$node" 2>/dev/null | awk \
    -v BLUE="$BLUE" -v RESET="$RESET" '
    {
      for (i=1; i<=NF; i++) {
        split($i, kv, "=")
        if (kv[1] != "" && kv[2] != "")
          v[kv[1]] = kv[2]
      }
    }
    END {
      if (!v["NodeName"]) { print "Node not found:", "'"$node"'"; exit }

      printf("%sNode:%s        %s\n", BLUE, RESET, v["NodeName"])
      if (v["State"]) printf("%sState:%s       %s\n", BLUE, RESET, v["State"])

      if (v["Sockets"] && v["CoresPerSocket"] && v["ThreadsPerCore"])
        printf("%sTopology:%s    %s sockets x %s cores x %s threads\n",
               BLUE, RESET,
               v["Sockets"], v["CoresPerSocket"], v["ThreadsPerCore"])

      if (v["CPUAlloc"] && v["CPUTot"])
        printf("%sCPUs:%s        %s alloc / %s total (%s free)\n",
               BLUE, RESET,
               v["CPUAlloc"], v["CPUTot"],
               v["CPUTot"] - v["CPUAlloc"])

      if (v["CPULoad"])
        printf("%sLoad:%s        %s\n", BLUE, RESET, v["CPULoad"])

      # Memory in MB -> GB
      if (v["RealMemory"] && v["AllocMem"])
        printf("%sMemory:%s      %.1fG alloc / %.1fG total (%.1fG free)\n",
               BLUE, RESET,
               v["AllocMem"]/1024.0,
               v["RealMemory"]/1024.0,
               (v["RealMemory"]-v["AllocMem"])/1024.0)

      if (v["Gres"])
        printf("%sGRES:%s        %s\n", BLUE, RESET, v["Gres"])

      if (v["AvailableFeatures"])
        printf("%sFeatures:%s    %s\n", BLUE, RESET, v["AvailableFeatures"])
    }'
}

# ---- sumpart ----
#
# summarize the partition or project <partition>
# sumpart <part>
#
sumpart() {
  local part="$1"
  if [[ -z "$part" ]]; then
    echo "Usage: sumpart <partition>"
    echo "Tip:   lsparts"
    return 1
  fi

  local BLUE="\033[34m" RESET="\033[0m"

  sinfo -h -p "$part" -o "%P|%l|%D|%C|%m" | awk -F'|' -v BLUE="$BLUE" -v RESET="$RESET" '
    {
      pname=$1; tl=$2; nodes=$3; c=$4; mem=$5
      if (pname ~ /\*$/) sub(/\*$/, "", pname)

      split(c, a, "/") # alloc/idle/other/total

      printf("%sPartition:%s   %s\n", BLUE, RESET, pname)
      printf("%sTime limit:%s  %s\n", BLUE, RESET, tl)
      printf("%sNodes:%s       %s\n", BLUE, RESET, nodes)
      printf("%sCPUs:%s        %s in use, %s idle, %s total\n", BLUE, RESET, a[1], a[2], a[4])

      # mem is per node in MB (often). Keep non-numeric as-is.
      if (mem ~ /^[0-9]+$/) printf("%sMem/node:%s    %.0fG\n", BLUE, RESET, mem/1024.0)
      else if (mem != "N/A" && mem != "") printf("%sMem/node:%s    %s\n", BLUE, RESET, mem)
    }'
}


