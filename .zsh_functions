# --------------------------------------------------
# ~/.zsh_functions
# --------------------------------------------------

# ---- helpers ----
#
_slurm_blue() { printf "\033[94m"; }
_slurm_reset() { printf "\033[0m"; }

# ---- lsjobs  ----
#
# list all (user) jobs in a human-readable format
#
lsjobs() {
  local who="${1:-$USER}"
  local BLUE="$(_slurm_blue)"
  local RESET="$(_slurm_reset)"

  squeue -u "$who" -h -o "%i|%t|%P|%j|%C|%m|%M|%D|%R" | awk -F'|' \
    -v BLUE="$BLUE" -v RESET="$RESET" '
    BEGIN {
      printf "%-10s %-5s %-14s %-26s %-4s %-6s %-10s %-5s %s\n",
             "JOBID","ST","PARTITION","NAME","CPU","MEM","TIME","NODES","WHERE/REASON"
    }
    {
      # colorize only the JOBID column
      printf "%s%-10s%s %-5s %-14s %-26.26s %-4s %-6s %-10s %-5s %s\n",
             BLUE, $1, RESET,
             $2, $3, $4, $5, $6, $7, $8, $9
    }'
}

# ---- lsnodes ----
#
# list all the nodes in a human-readable format
#
lsnodes() {
  local part="$1"
  local BLUE="$(_slurm_blue)"
  local RESET="$(_slurm_reset)"
  local fmt="%15N %4c %7m %46f %18G"
  local cmd=(sinfo -h -o "$fmt")
  [[ -n "$part" ]] && cmd+=(-p "$part")

  printf "%-15s %-4s %-7s %-46s %-18s\n" "NODELIST" "CPUS" "MEM" "FEATURES" "RESOURCES"

  "${cmd[@]}" | awk -v BLUE="$BLUE" -v RESET="$RESET" '
    function trim(s){ sub(/^[[:space:]]+/, "", s); sub(/[[:space:]]+$/, "", s); return s }

    # sinfo %m is MB (usually). Keep non-numeric values like 56000+ as-is.
    function human_mem(m, gb){
      if (m !~ /^[0-9]+$/) return m
      gb = m/1024.0
      if (gb >= 1024.0) return sprintf("%.1fT", gb/1024.0)
      return sprintf("%.0fG", gb)
    }

    # Make resources readable but keep the raw label visible.
    # gpu:h100:3 -> 3_H100 (gpu:h100:3)
    function human_gres_with_raw(g,   out,n,i,raw,base,tok,parts){
      g = trim(g)
      if (g=="" || g=="(null)" || g=="N/A") return "-"

      n = split(g, parts, ",")
      out = ""
      for (i=1; i<=n; i++) {
        raw = trim(parts[i]); if (raw=="") continue
        base = raw; sub(/\(.*/, "", base)  # drop (S:0-1) from parsing only

        tok = raw
        if (match(base, /^gpu:([^:]+):([0-9]+)$/, m)) {
          tok = m[2] "_" toupper(m[1]) " (" raw ")"
        } else if (match(base, /^gpu:([^:]+)$/, m2)) {
          tok = toupper(m2[1]) " (" raw ")"
        }

        if (out!="") out = out ", "
        out = out tok
      }
      return out
    }

    {
      nl   = trim(substr($0, 1, 15))
      cpus = trim(substr($0, 17, 4))
      mem  = trim(substr($0, 22, 7))
      feat = trim(substr($0, 30, 46))
      gres = trim(substr($0, 77, 18))

      printf("%s%-15s%s %-4s %-7s %-46s %s\n",
             BLUE, nl, RESET,
             cpus,
             human_mem(mem),
             feat,
             human_gres_with_raw(gres))
    }'
}

# ---- lsparts ----
#
# list partitions (and projects)  in a human-readable format
#
lsparts() {

  local BLUE="$(_slurm_blue)"
  local RESET="$(_slurm_reset)"

  sinfo -h -o "%P|%D|%C" | awk -F'|' -v BLUE="$BLUE" -v RESET="$RESET" '
    {
      pname=$1; nodes=$2; c=$3
      suffix=""
      if (pname ~ /\*$/) { sub(/\*$/, "", pname); suffix=" (default)" }

      split(c, a, "/") # alloc/idle/other/total

      printf("%s%-20s%s %4s nodes, %4s idle CPUs / %s%s\n",
             BLUE, pname, RESET,
             nodes, a[2], a[4], suffix)
    }'
}

# ---- sumjob ----
# 
# summarize the job with <jobid>
# sumjob <jobid>
#
sumjob() {
  local jobid="$1"
  if [[ -z "$jobid" ]]; then
    echo "Usage: sumjob <jobid>"
    echo "Tip:   lsjobs"
    return 1
  fi

  local BLUE="$(_slurm_blue)"
  local RESET="$(_slurm_reset)"

  # 1) Try live snapshot first
  local live
  live="$(scontrol show job "$jobid" 2>/dev/null)"
  if [[ -n "$live" ]]; then
    print -r -- "$live" | awk -v BLUE="$BLUE" -v RESET="$RESET" -v jobid="$jobid" '
      {
        for (i=1; i<=NF; i++) {
          split($i, kv, "=")
          if (kv[1] != "" && kv[2] != "") v[kv[1]] = kv[2]
        }
      }
      END {
        if (!v["JobId"]) { print "Job not found: " jobid; exit 0 }

        printf("%sJob:%s         %s\n", BLUE, RESET, v["JobId"])
        if (v["JobName"])   printf("%sName:%s        %s\n", BLUE, RESET, v["JobName"])
        if (v["UserId"])    printf("%sUser:%s        %s\n", BLUE, RESET, v["UserId"])
        if (v["Partition"]) printf("%sPartition:%s   %s\n", BLUE, RESET, v["Partition"])
        if (v["State"])     printf("%sState:%s       %s\n", BLUE, RESET, v["State"])
        if (v["Reason"])    printf("%sReason:%s      %s\n", BLUE, RESET, v["Reason"])

        if (v["SubmitTime"]) printf("%sSubmitted:%s   %s\n", BLUE, RESET, v["SubmitTime"])
        if (v["StartTime"])  printf("%sStart:%s       %s\n", BLUE, RESET, v["StartTime"])
        if (v["RunTime"])    printf("%sRunTime:%s     %s\n", BLUE, RESET, v["RunTime"])
        if (v["TimeLimit"])  printf("%sTimeLimit:%s   %s\n", BLUE, RESET, v["TimeLimit"])

        if (v["NumNodes"])   printf("%sNodes:%s       %s\n", BLUE, RESET, v["NumNodes"])
        if (v["NodeList"])   printf("%sNodeList:%s    %s\n", BLUE, RESET, v["NodeList"])

        if (v["NumCPUs"])    printf("%sCPUs:%s        %s\n", BLUE, RESET, v["NumCPUs"])
        if (v["ReqMem"])     printf("%sReqMem:%s      %s\n", BLUE, RESET, v["ReqMem"])
        if (v["TRES"])       printf("%sTRES:%s        %s\n", BLUE, RESET, v["TRES"])
        if (v["Gres"])       printf("%sGres:%s        %s\n", BLUE, RESET, v["Gres"])
        if (v["StdOut"])     printf("%sStdOut:%s      %s\n", BLUE, RESET, v["StdOut"])
        if (v["StdErr"])     printf("%sStdErr:%s      %s\n", BLUE, RESET, v["StdErr"])
      }'
    return 0
  fi

  # 2) Fallback: accounting (works for completed jobs)
  sacct -j "$jobid" -n -X \
    -o JobID,JobName%26,User,Partition,State,ExitCode,Elapsed,Timelimit,AllocCPUS,ReqMem,MaxRSS,NodeList%30 |
  awk -v BLUE="$BLUE" -v RESET="$RESET" -v jobid="$jobid" '
    BEGIN {
      printf("%sJob (acct):%s  %s\n", BLUE, RESET, jobid)
      printf("%-12s %-26s %-10s %-12s %-10s %-10s %-10s %-10s %-8s %-10s %-10s %s\n",
             "JOBID","NAME","USER","PARTITION","STATE","EXIT","ELAPSED","TLIMIT","CPUS","REQMEM","MAXRSS","NODELIST")
    }
    NF {
      printf("%-12s %-26s %-10s %-12s %-10s %-10s %-10s %-10s %-8s %-10s %-10s %s\n",
             $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12)
    }'
}

# ---- sumnode ----
#
# summarize the node <nodeid>
# sumnode <nodeid>
#
sumnode() {
  local node="$1"
  if [[ -z "$node" ]]; then
    echo "Usage: sumnode <node>"
    echo "Tip:   lsnodes"
    return 1
  fi

  local BLUE="$(_slurm_blue)"
  local RESET="$(_slurm_reset)"

  scontrol show node "$node" 2>/dev/null | awk \
    -v BLUE="$BLUE" -v RESET="$RESET" '
    {
      for (i=1; i<=NF; i++) {
        split($i, kv, "=")
        if (kv[1] != "" && kv[2] != "")
          v[kv[1]] = kv[2]
      }
    }
    END {
      if (!v["NodeName"]) { print "Node not found:", "'"$node"'"; exit }

      printf("%sNode:%s        %s\n", BLUE, RESET, v["NodeName"])
      if (v["State"]) printf("%sState:%s       %s\n", BLUE, RESET, v["State"])

      if (v["Sockets"] && v["CoresPerSocket"] && v["ThreadsPerCore"])
        printf("%sTopology:%s    %s sockets x %s cores x %s threads\n",
               BLUE, RESET,
               v["Sockets"], v["CoresPerSocket"], v["ThreadsPerCore"])

      if (v["CPUAlloc"] && v["CPUTot"])
        printf("%sCPUs:%s        %s alloc / %s total (%s free)\n",
               BLUE, RESET,
               v["CPUAlloc"], v["CPUTot"],
               v["CPUTot"] - v["CPUAlloc"])

      if (v["CPULoad"])
        printf("%sLoad:%s        %s\n", BLUE, RESET, v["CPULoad"])

      # Memory in MB -> GB
      if (v["RealMemory"] && v["AllocMem"])
        printf("%sMemory:%s      %.1fG alloc / %.1fG total (%.1fG free)\n",
               BLUE, RESET,
               v["AllocMem"]/1024.0,
               v["RealMemory"]/1024.0,
               (v["RealMemory"]-v["AllocMem"])/1024.0)

      if (v["Gres"])
        printf("%sGRES:%s        %s\n", BLUE, RESET, v["Gres"])

      if (v["AvailableFeatures"])
        printf("%sFeatures:%s    %s\n", BLUE, RESET, v["AvailableFeatures"])
    }'
}

# ---- sumpart ----
#
# summarize the partition or project <partition>
# sumpart <part>
#
sumpart() {
  local part="$1"
  if [[ -z "$part" ]]; then
    echo "Usage: sumpart <partition>"
    echo "Tip:   lsparts"
    return 1
  fi

  local BLUE="$(_slurm_blue)"
  local RESET="$(_slurm_reset)"

  sinfo -h -p "$part" -o "%P|%l|%D|%C|%m" | awk -F'|' -v BLUE="$BLUE" -v RESET="$RESET" '
    {
      pname=$1; tl=$2; nodes=$3; c=$4; mem=$5
      if (pname ~ /\*$/) sub(/\*$/, "", pname)

      split(c, a, "/") # alloc/idle/other/total

      printf("%sPartition:%s   %s\n", BLUE, RESET, pname)
      printf("%sTime limit:%s  %s\n", BLUE, RESET, tl)
      printf("%sNodes:%s       %s\n", BLUE, RESET, nodes)
      printf("%sCPUs:%s        %s in use, %s idle, %s total\n", BLUE, RESET, a[1], a[2], a[4])

      # mem is per node in MB (often). Keep non-numeric as-is.
      if (mem ~ /^[0-9]+$/) printf("%sMem/node:%s    %.0fG\n", BLUE, RESET, mem/1024.0)
      else if (mem != "N/A" && mem != "") printf("%sMem/node:%s    %s\n", BLUE, RESET, mem)
    }'
}

# --- lastjob ---
#
# print the job ID of the most recently recorded job for the current user.
#
# Typical use:
#   lastjob
#   seff "$(lastjob)"
#   squeue -j "$(lastjob)"
#   cd "$(lastjob)"
#   
lastjob() {
  sacct -u "$USER" -n -X -o JobID,Submit |
    awk '
      $1 ~ /^[0-9]+(_[0-9]+)?$/ && $2 ~ /^[0-9]{4}-/ {
        if ($2 > bestt) { bestt = $2; best = $1 }
      }
      END { if (best != "") print best }
    '
}

# --- lsqueue ---
#
# List queued/running jobs (optionally for a specific user)
#   lsqueue            # current user
#   lsqueue alice      # another user
#
lsqueue() {
  local who="${1:-$USER}"
  local BLUE="$(_slurm_blue)"
  local RESET="$(_slurm_reset)"

  squeue -u "$who" -h -o "%i|%t|%P|%u|%j|%C|%m|%M|%D|%R" |
    awk -F'|' -v BLUE="$BLUE" -v RESET="$RESET" '
      BEGIN {
        printf "%-10s %-5s %-14s %-10s %-26s %-4s %-6s %-10s %-5s %s\n",
               "JOBID","ST","PARTITION","USER","NAME","CPU","MEM","TIME","NODES","WHERE/REASON"
      }
      {
        # colorize only JOBID
        printf "%s%-10s%s %-5s %-14s %-10s %-26.26s %-4s %-6s %-10s %-5s %s\n",
               BLUE, $1, RESET,
               $2, $3, $4, $5, $6, $7, $8, $9, $10
      }'
}
# ---- effjob ----
#
# show efficiency information for a job with <jobid>
#
effjob() {
  local jobid="$1"
  local BLUE="$(_slurm_blue)"
  local RESET="$(_slurm_reset)"

  if [[ -z "$jobid" ]]; then
    echo "Usage: effjob <jobid|last|lastjob>"
    return 1
  fi

  if [[ "$jobid" == "last" || "$jobid" == "lastjob" ]]; then
    jobid="$(lastjob)"
    [[ -n "$jobid" ]] || { echo "No last job found." >&2; return 1; }
  fi

  if ! command -v seff >/dev/null 2>&1; then
    echo "seff not found in PATH."
    return 127
  fi

  command seff "$jobid" |
  awk -v BLUE="$BLUE" -v RESET="$RESET" '
    {
      line = $0

      # abbreviations
      gsub(/ core-walltime/, " (core-wt)", line)
      gsub(/ of /, " / ", line)

      # colorize left-side labels (text before first colon)
      if (match(line, /^[[:space:]]*[^:]+:/)) {
        label = substr(line, RSTART, RLENGTH-1)
        rest  = substr(line, RLENGTH+1)
        printf "%s%s%s:%s%s\n", BLUE, label, RESET, RESET, rest
      } else {
        print line
      }
    }
  '
}

# --- lsqueue ---
#
# list queued/running jobs for the current user
#
lsqueue() {
  local BLUE="$(_slurm_blue)"
  local RESET="$(_slurm_reset)"

  squeue -u "$USER" -h -o "%i|%t|%P|%u|%j|%C|%m|%M|%D|%R" |
    awk -F'|' -v BLUE="$BLUE" -v RESET="$RESET" '
      BEGIN {
        printf "%-10s %-5s %-14s %-10s %-26s %-4s %-6s %-10s %-5s %s\n",
               "JOBID","ST","PARTITION","USER","NAME","CPU","MEM","TIME","NODES","WHERE/REASON"
      }
      {
        printf "%s%-10s%s %-5s %-14s %-10s %-26.26s %-4s %-6s %-10s %-5s %s\n",
               BLUE, $1, RESET,
               $2, $3, $4, $5, $6, $7, $8, $9, $10
      }'
}

